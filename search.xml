<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2025/03/14/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>起点</title>
    <url>/2025/03/15/%E8%B5%B7%E7%82%B9/</url>
    <content><![CDATA[<h1 id="全新的开始"><a href="#全新的开始" class="headerlink" title="全新的开始"></a>全新的开始</h1><p>创建这个博客，希望能记录下自己一点一滴的变化</p>
<hr>
]]></content>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>计网学习企划</title>
    <url>/2025/03/16/%E8%AE%A1%E7%BD%91%E5%AD%A6%E4%B9%A0%E4%BC%81%E5%88%92/</url>
    <content><![CDATA[<h1 id="新的篇章"><a href="#新的篇章" class="headerlink" title="新的篇章"></a>新的篇章</h1><p>计划以计算机网络的学习作为自己在后端学习的起点。<br>当然也会同步学习java等后端开发所需要的语言。</p>
<h1 id="学习渠道"><a href="#学习渠道" class="headerlink" title="学习渠道"></a>学习渠道</h1><p>以B站的计算机网络视频<a href="https://www.bilibili.com/video/BV1JV411t7ow/?spm_id_from=333.337.search-card.all.click&vd_source=aee9954bc08c112ebede8a68e01d7f6b">中科大郑烇、杨坚全套《计算机网络（自顶向下方法 第7版，James F.Kurose，Keith W.Ross）》课程</a>为主。<br>课件采用视频中所使用的PPT</p>
<blockquote>
<p><a href="https://pan.baidu.com/s/1EElOrkkY4WQqgeKHuGm-bg">https://pan.baidu.com/s/1EElOrkkY4WQqgeKHuGm-bg</a> 密码:1958</p>
</blockquote>
<h1 id="学习分享"><a href="#学习分享" class="headerlink" title="学习分享"></a>学习分享</h1><p>每学习完一个章节，都将发布一篇博客，记录这一章所学内容，希望自己能不断提高，变得更加优秀。</p>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>STL常用组件</title>
    <url>/2025/03/19/STL%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<h1>前言</h1>
<p>该篇博客旨在忘记STL用法时查询</p>
<hr>
<h1>正文</h1>
<h2 id="pair">pair</h2>
<p>二元组，可以组合任意两个不同类型（或相同类型）的元素。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;utility&gt;</span></span><br></code></pre></td></tr></table></figure>
<h3 id="成员变量">成员变量</h3>
<table>
<thead>
<tr>
<th>变量名</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>first</td>
<td>第一个值</td>
</tr>
<tr>
<td>second</td>
<td>第二个值</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="stack">stack</h2>
<p>栈。只允许在栈顶进行插入和删除操作。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stack&gt;</span></span><br></code></pre></td></tr></table></figure>
<h3 id="定义与初始化">定义与初始化</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">std::stack&lt;<span class="hljs-type">int</span>&gt; s;<br><span class="hljs-comment">// s = &#123;&#125;</span><br></code></pre></td></tr></table></figure>
<h3 id="成员函数">成员函数</h3>
<table>
<thead>
<tr>
<th>函数名</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>top()</td>
<td>返回栈顶元素</td>
</tr>
<tr>
<td>empty()</td>
<td>返回是否为空</td>
</tr>
<tr>
<td>size()</td>
<td>返回元素个数</td>
</tr>
<tr>
<td>push(value)</td>
<td>在栈顶插入 <strong>value</strong></td>
</tr>
<tr>
<td>pop()</td>
<td>删除栈顶元素</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="queue">queue</h2>
<p>队列。只允许在队尾插入元素，在队头删除元素</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br></code></pre></td></tr></table></figure>
<h3 id="定义与初始化-2">定义与初始化</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">std::queue&lt;<span class="hljs-type">int</span>&gt; q;<br><span class="hljs-comment">// q = &#123;&#125;</span><br></code></pre></td></tr></table></figure>
<h3 id="成员函数-2">成员函数</h3>
<table>
<thead>
<tr>
<th>函数名</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>front()</td>
<td>返回队头元素</td>
</tr>
<tr>
<td>back()</td>
<td>返回队尾元素</td>
</tr>
<tr>
<td>empty()</td>
<td>返回是否为空</td>
</tr>
<tr>
<td>size()</td>
<td>返回元素个数</td>
</tr>
<tr>
<td>push(value)</td>
<td>在队尾插入元素 <strong>value</strong></td>
</tr>
<tr>
<td>pop()</td>
<td>删除队头元素</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="priority-queue">priority_queue</h2>
<p>优先队列。会自动排序，但其内部元素不可见，只允许访问最大的元素。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br></code></pre></td></tr></table></figure>
<h3 id="定义和初始化">定义和初始化</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">std::priority_queue&lt;<span class="hljs-type">int</span>&gt; pq<br></code></pre></td></tr></table></figure>
<p><strong>priority_queue</strong>默认为大根堆（只允许访问最大的元素）。以下是小根堆的写法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br>std::priority_queue&lt;<span class="hljs-type">int</span>, std::vector&lt;<span class="hljs-type">int</span>&gt;, std::greater&lt;<span class="hljs-type">int</span>&gt;&gt; pq<br></code></pre></td></tr></table></figure>
<h3 id="成员函数-3">成员函数</h3>
<table>
<thead>
<tr>
<th>函数名</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>top()</td>
<td>返回最大的元素</td>
</tr>
<tr>
<td>empty()</td>
<td>返回是否为空</td>
</tr>
<tr>
<td>size()</td>
<td>返回元素个数</td>
</tr>
<tr>
<td>push(value)</td>
<td>往堆中插入 <strong>value</strong></td>
</tr>
<tr>
<td>pop()</td>
<td>删除最大的元素</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="vector">vector</h2>
<p>动态数组。能根据需要自动扩容，也能手动调整容量。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br></code></pre></td></tr></table></figure>
<h3 id="定义与初始化-3">定义与初始化</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>vector&lt;<span class="hljs-type">int</span>&gt; v1;<br><span class="hljs-comment">// v = &#123;&#125;</span><br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v2</span><span class="hljs-params">(n + <span class="hljs-number">5</span>)</span></span>;<br><br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">v3</span>(n + <span class="hljs-number">5</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n + <span class="hljs-number">5</span>));<br></code></pre></td></tr></table></figure>
<h3 id="成员函数-4">成员函数</h3>
<table>
<thead>
<tr>
<th>函数名</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>at(pos)</td>
<td>返回第 <strong>pos</strong> 个元素</td>
</tr>
<tr>
<td>operater [pos]</td>
<td>返回第 <strong>pos</strong> 个元素</td>
</tr>
<tr>
<td>assign(count, value)</td>
<td>初始化为 <strong>count</strong> 个 <strong>value</strong></td>
</tr>
<tr>
<td>front()</td>
<td>返回第一个元素</td>
</tr>
<tr>
<td>back()</td>
<td>返回最后一个元素</td>
</tr>
<tr>
<td>begin()</td>
<td>返回头部迭代器</td>
</tr>
<tr>
<td>end()</td>
<td>返回尾部迭代器</td>
</tr>
<tr>
<td>empty()</td>
<td>返回是否为空</td>
</tr>
<tr>
<td>size()</td>
<td>返回元素个数</td>
</tr>
<tr>
<td>clear()</td>
<td>清空</td>
</tr>
<tr>
<td>push_back(value)</td>
<td>在尾部插入 <strong>value</strong></td>
</tr>
<tr>
<td>pop_back()</td>
<td>删除尾部元素</td>
</tr>
<tr>
<td>resize(count)</td>
<td>将容量调整为 <strong>count</strong></td>
</tr>
</tbody>
</table>
<blockquote>
<p>STL中的 begin() 均指向头部元素； end() 指向尾部元素的后继，而非尾部元素。</p>
</blockquote>
<h3 id="实例">实例</h3>
<p>以下是遍历 vector<int> a，并输出所有元素的三种方式</p>
<figure class="highlight mel"><table><tr><td class="code"><pre><code class="hljs mel"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; a.<span class="hljs-keyword">size</span>();i ++)<br>    cout &lt;&lt; a[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;::iterator it = a.begin();it != a.end();it ++)<br>    cout &lt;&lt; a[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> v : a[n])<br>    cout &lt;&lt; a[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br></code></pre></td></tr></table></figure>
<p>用vector代替邻接表保存有向图</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX_EDGES = <span class="hljs-number">100010</span>;<br>vector&lt;<span class="hljs-type">int</span>&gt; ver[MAX_EDGES], edge[MAX_EDGES];<br><br><span class="hljs-comment">//保存从 u 到 v 权值为 val 的有向边</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>    ver[u].<span class="hljs-built_in">push_back</span>(v);<br>    edge[u].<span class="hljs-built_in">push_back</span>(val);<br>&#125;<br><span class="hljs-comment">//遍历从 x 出发的所有边</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; ver[u].<span class="hljs-built_in">size</span>();i ++)&#123;<br>    <span class="hljs-type">int</span> v = ver[u][i], val = edge[u][i];<br>    <span class="hljs-comment">//有向边 (u, v, val)</span><br>&#125;<br></code></pre></td></tr></table></figure>
<hr>
<h2 id="map">map</h2>
<p>映射。相当于 <strong>[]</strong> 内可填任意键值（可以是 <strong>int</strong> , <strong>double</strong> 等任意类型的对象）的数组</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#incldue<span class="hljs-string">&lt;map&gt;</span></span><br></code></pre></td></tr></table></figure>
<h3 id="定义和初始化-2">定义和初始化</h3>
<figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino">std::map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; m1;<br><br>std::map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; m2 = &#123; &#123;<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-number">1</span>&#125; &#125;;<br>m2 = &#123; &#123;<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-number">1</span>&#125; &#125;<br></code></pre></td></tr></table></figure>
<h3 id="成员函数-5">成员函数</h3>
<table>
<thead>
<tr>
<th>函数名</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>at(key)</td>
<td>返回 <strong>key</strong> 映射的元素</td>
</tr>
<tr>
<td>operator[key]</td>
<td>返回 <strong>key</strong> 映射的元素，若没有则创造键</td>
</tr>
<tr>
<td>begin()</td>
<td>返回头部迭代器</td>
</tr>
<tr>
<td>end()</td>
<td>返回尾部迭代器</td>
</tr>
<tr>
<td>empty()</td>
<td>返回是否为空</td>
</tr>
<tr>
<td>size()</td>
<td>返回元素个数</td>
</tr>
<tr>
<td>clear()</td>
<td>清空</td>
</tr>
<tr>
<td>count(key)</td>
<td>返回 <strong>key</strong> 映射的元素的个数</td>
</tr>
<tr>
<td>insert({key, value})</td>
<td>创建从 <strong>key</strong> 到 <strong>value</strong> 的映射</td>
</tr>
<tr>
<td>erase(key)</td>
<td>删除从 <strong>key</strong> 出发的映射</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="set">set</h2>
<p>集合。插入其中的每种元素都只保留其一，并自动升序排序。</p>
<blockquote>
<p>STL 提供 multiset (多重集)，相同的元素允许存在多个，其他功能与 set 一致</p>
</blockquote>
<figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;set&gt;</span> </span><br></code></pre></td></tr></table></figure>
<h3 id="定义和初始化-3">定义和初始化</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">std::set&lt;<span class="hljs-type">int</span>&gt; s1;<br><span class="hljs-comment">//s1 = &#123;&#125;</span><br><br>std::set&lt;<span class="hljs-type">int</span>&gt; s2 = &#123;<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;p&#x27;</span>, <span class="hljs-string">&#x27;p&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>&#125;;<br><span class="hljs-comment">//s2 = &#123;&#x27;a&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;p&#x27;&#125;</span><br></code></pre></td></tr></table></figure>
<h3 id="成员函数-6">成员函数</h3>
<table>
<thead>
<tr>
<th>函数名</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>begin()</td>
<td>返回头部迭代器</td>
</tr>
<tr>
<td>end()</td>
<td>返回尾部迭代器</td>
</tr>
<tr>
<td>empty()</td>
<td>返回是否为空</td>
</tr>
<tr>
<td>size()</td>
<td>返回元素个数</td>
</tr>
<tr>
<td>clear()</td>
<td>清空</td>
</tr>
<tr>
<td>insert(value)</td>
<td>插入 <strong>value</strong></td>
</tr>
<tr>
<td>pop(value)</td>
<td>删除 <strong>value</strong></td>
</tr>
<tr>
<td>count(value)</td>
<td>返回 <strong>value</strong> 的个数</td>
</tr>
</tbody>
</table>
<hr>
<h1>后记</h1>
<p>由于C++容器库包含的容器太多，在此处不一一赘述，更详细的教程请在<a href="https://zh.cppreference.com/w/cpp/container">此处</a>查找。<br>
后续还会补充一些常用容器。</p>
]]></content>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构初步</title>
    <url>/2025/03/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%9D%E6%AD%A5/</url>
    <content><![CDATA[<h1>前言</h1>
<p>数据结构的设计思路来源于程序设计中的各种基本算法思想，同时又对进一步研究和实现更加深入的算法提供的工具技术，此篇文章旨在探讨一些基础的线性数据结构和树形数据结构。</p>
<h1>正文</h1>
<h2 id="哈希">哈希</h2>
<h3 id="哈希表">哈希表</h3>
<p>哈希表与离散化思想类似，可以用 Hash 函数把一系列复杂的信息映射到一个容易维护的值域内。<br>
Hash 表主要包含两个基本操作：</p>
<ol>
<li>计算 Hash 函数的值；</li>
<li>定位到对应链表中依次遍历、比较。<br>
当 Hash 函数设计较好时，原始信息会被比较均匀地分配到各个表头之后。若原始信息总数与表头数组长度都是 O(N) 级别且 Hash 函数分散均匀，几乎不产生冲突，那么查找、统计地时间复杂度期望为 O(1)。<br>
下面我们来介绍 Hash 表的做法：<br>
设计 Hash 函数为 H(x) = (x mod P) + 1，其中 P 是一个比较大的质数，但不超过 N。显然，这个Hash函数把数列 A 分为 P 类，我们可以一次考虑数列中的每个数 A[i]，定位到 head[H(A[i])] 这个表头所指向的链表。如果该链表中不包含 A[i]，我们就在表头后插入一个新节点 A[i]，并在该节点上记录 A[i] 出现了 1 次，否则就直接找到已经存在的 A[i]节点并将其出现次数加 1。因为整数序列 A 是随机的，所以最终所有的 A[i] 会比较均匀地分散在各个表头之后，整个算法的复杂度可以近似达到 O(n)。</li>
</ol>
<h4 id="例题-Snowflake-Snow-Snowflakes"><a href="http://poj.org/problem?id=3349">例题 Snowflake Snow Snowflakes</a></h4>
<blockquote>
<p>雪花上有 6 个数形成环状，只有当从某个位置为起点，按顺时针或逆时针，能完全和另一个雪花相同时，判断为有两个相同的雪花。现有 n 片雪花，判断是否存在两片相同的雪花。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">const <span class="hljs-type">int</span> <span class="hljs-variable">SIZE</span> <span class="hljs-operator">=</span> <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> n, tot, P = <span class="hljs-number">99991</span>, snow[SIZE][<span class="hljs-number">6</span>], head[SIZE], next[SIZE];<br><span class="hljs-type">int</span> <span class="hljs-title function_">H</span><span class="hljs-params">(<span class="hljs-type">int</span> *a)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, mul = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">6</span>;i ++) &#123;<br>        sum = (sun + a[i]) % P;<br>        mul = (<span class="hljs-type">long</span> <span class="hljs-type">long</span>) mul * a[i] % P;<br>    &#125;<br>    <span class="hljs-keyword">return</span> (sum + mul) % P;<br>&#125;<br><br>bool <span class="hljs-title function_">equal</span><span class="hljs-params">(<span class="hljs-type">int</span> *a, <span class="hljs-type">int</span> *b)</span> &#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">6</span>;i ++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;j &lt; <span class="hljs-number">6</span>;j ++) &#123;<br>            <span class="hljs-type">bool</span> <span class="hljs-variable">eq</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;k &lt; <span class="hljs-number">6</span>;k ++) &#123;<br>                <span class="hljs-keyword">if</span>(a[(i + k) % <span class="hljs-number">6</span>] != b[(j + k) % <span class="hljs-number">6</span>]) eq = <span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(eq) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;k &lt; <span class="hljs-number">6</span>;k ++&#123;<br>                <span class="hljs-keyword">if</span>(a[(i + k) % <span class="hljs-number">6</span>] != b[(j - k + <span class="hljs-number">6</span>) % <span class="hljs-number">6</span>]) eq = <span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(eq) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>bool <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> *a)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> H(a);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> head[val];i;i = next[i]) &#123;<br>        <span class="hljs-keyword">if</span>(equal(snow[i], a)) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    ++ tot;<br>    memcpy(sonw[tot], a, <span class="hljs-number">6</span> * sizeof(<span class="hljs-type">int</span>));<br>    next[tot] = head[val];<br>    head[val] = tot;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;i &lt;= n;i ++)&#123;<br>        <span class="hljs-type">int</span> a[<span class="hljs-number">10</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;j &lt; <span class="hljs-number">6</span>;j ++) cin &gt;&gt; a[j];<br>        <span class="hljs-keyword">if</span>(insert(a)) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;Twin snowflakes found.&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;No two snowflakes are alike.&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="字符串Hash">字符串Hash</h3>
<p>字符串 Hash 可以将一个任意长度的字符串映射成一个非负整数，并且其冲突概率几乎为零。<br>
<strong>取一固定值 P，把字符串看成 P 进制数，并分配一个大于 0 的数值，代表每种字符</strong>。一般来说，我们分配的数值远小于 P。例如对于小写字母构成的字符串，可以令 a = 1,b = 2,···,z = 26。<strong>取一固定值 M，求出该 P 进制数对 M 的余数，作为该字符串的 Hash 值</strong>。<br>
一般来说，我们取 P = 131 或 P = 13331，此时 Hash 值产生冲突的概率极低，只要 Hash 值相同，我们就可以认为原字符串是相等的。通常我们取 M = 2<sup>64</sup>，即<strong>直接使用 unsighed long long 类型</strong>来存储这个 Hash 值，在计算时不处理算术溢出问题，产生溢出相当于自动对 2<sup>64</sup> 取模，这样可以避免低效的取模 (mod) 运算。<br>
如果我们已知字符串 S 的 Hash 值为 H(S)，那么在 S 后添加一个字符 c 构成新的字符串 S + c 的 Hash 值就是 H(S + c) = (H(S) * P + value[c]) mod M。其中乘 P 就相当于 P 进制下的左移运算，value[c] 是我们为 c 选定的代表数值。<br>
如果我们已知字符串 S 的 Hash 值为 H(S)，字符串 S + T 的 Hash 值为 H(S + T)，那么字符串 T 的 Hash 值 H(T) = (H(S + T) - H(S) * P<sup>length(T)</sup>) mod M。</p>
<p>我们可以通过 <strong>O(N) 的时间预处理字符串所有前缀 Hash 值，并在 O(1) 的时间内查询它任意字串的 Hash 值</strong>。</p>
<h4 id="例题-兔子与兔子"><a href="https://www.acwing.com/problem/content/140/">例题 兔子与兔子</a></h4>
<blockquote>
<p>很久很久以前，森林里住着一群兔子。<br>
有一天，兔子们想要研究自己的 DNA 序列。<br>
我们首先选取一个好长好长的 DNA 序列（小兔子是外星生物，DNA 序列可能包含 26个小写英文字母）。<br>
然后我们每次选择两个区间，询问如果用两个区间里的 DNA 序列分别生产出来两只兔子，这两个兔子是否一模一样。<br>
注意两个兔子一模一样只可能是他们的 DNA 序列一模一样。<br>
1≤length(S),m≤1000000</p>
</blockquote>
<figure class="highlight prolog"><table><tr><td class="code"><pre><code class="hljs prolog">char s[<span class="hljs-number">1000010</span>];<br>unsigned long long f[<span class="hljs-number">1000010</span>], p[<span class="hljs-number">1000010</span>];<br>int main() &#123;<br>    scanf(<span class="hljs-string">&quot;%s&quot;</span>, s + <span class="hljs-number">1</span>);<br>    int n = strlen(s + <span class="hljs-number">1</span>), q;<br>    cin &gt;&gt; q;<br>    p[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    for(int i = <span class="hljs-number">1</span>;i &lt;= n;i ++) &#123;<br>        f[i] = f[i - <span class="hljs-number">1</span>] * <span class="hljs-number">131</span> + (s[i] - <span class="hljs-string">&#x27;a&#x27;</span> + <span class="hljs-number">1</span>);<br>        p[i] = p[i - <span class="hljs-number">1</span>] * <span class="hljs-number">131</span>;<br>    &#125;<br>    for(int i = <span class="hljs-number">1</span>;i &lt;= q;i ++) &#123;<br>        int l1, l2 ,r1, r2;<br>        cin &gt;&gt; l1 &gt;&gt; l2 &gt;&gt; r1 &gt;&gt; r2;<br>        if(f[r1] - f[l1 - <span class="hljs-number">1</span>] * p[r1 - l1 + <span class="hljs-number">1</span>] == f[r2] - f[l2 - <span class="hljs-number">1</span>] * p[r2 - l2 + <span class="hljs-number">1</span>]) cout &lt;&lt; <span class="hljs-string">&quot;Yes&quot;</span> &lt;&lt; endl;<br>        else cout &lt;&lt; <span class="hljs-string">&quot;No&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1>未完待续</h1>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>哈希</tag>
        <tag>分块</tag>
        <tag>树状数组</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
</search>
